= 実践UserPool

//abstract{
UserPoolの初期設定・開発のオススメを紹介します。
//}

=={sec-ext} UserPoolを採用したアーキテクチャ
コンシューマー向けのWebサイトにおいて、Cognitoを採用したあアーキテクチャを2通り紹介します。
ここではクライアント・サーバーともに同じサービス事業者が開発している前提で解説します。サービスを別の事業者のクライアントに提供する場合、UserPoolによるOAuthの提供について調べてみてください。
また、ユースケースとしては、他にもSPAにログイン機能を実装するケースや、エンタープライズの認証基盤の認証基盤として使うケースがありますが、それらについてはAWSの公式ドキュメントを参照ください。@<fn>{a81b8f32}
//footnote[a81b8f32][AWS Black Belt Online Seminar 2017 AWSにおけるアプリ認証パターンのご紹介https://www.slideshare.net/AmazonWebServicesJapan/aws-black-belt-online-seminar-2017-aws-80642202]


=== UserPoolをユーザー認証・認可基盤として利用するケース
UserPoolをクライアントによるユーザー認証とサーバーによるユーザー認証の両方で用いるケースです。

図: [ UserPool → API Gateway(UserPool認証) → バックエンド]

エンドユーザーはUserPoolに対してサインインを行い、クライアントはレスポンスとしてIDトークン・アクセストークン・リフレッシュトークンを受け取ります。  
このとき、UserPoolにサインインする方法としては、UserPoolがホストするログイン画面を用いる方法と、クライアントがAWS-SDKを用いてUserPoolに認証をリクエストする方法の2通りがあります。
UserPoolにホストされるUIを使えばログイン画面を自前で実装しないでよいですが、パスワードレス認証などカスタム認証フローには対応していません。要件に応じて選びましょう。

サーバーによるユーザー認証は、自前で実装するケース、API Gatewayのオーソライザーを用いるケース、ALBの認証アクションを用いるケースの3通りが考えられます。
いずれの場合でも、UserPoolからレスポンスされたIDトークンをトークンをサーバーへのリクエストに含め、サーバー側はUserPoolに対してIDトークンを検証するのがよいでしょう。  
今回は想定していませんが、外部のクライアントにサーバーへのアクセス権限を与えたい場合にはアクセストークンを用いてください。権限をカスタムで設定することも可能です。

個人的には、認証はマネージドサービスに任せ、エンジニアはサービス開発に集中するのが良いと思います。認証周りを自前で実装しないでよいだけでなく、ローカルで認証レスなデバッグができるからです。結合テストなども実装しやすいのではないでしょうか。


=== UserPoolをユーザー認証基盤として利用し、認可に別サービスを用いるケース

UserPoolをユーザー認証基盤として用い、認可は別のサービスに任せるケースです。認可を担うサービスとしては、例えばCognito Federated Identity, Authleteなどがあります。@<fn>{f5873f66}
//footnote[f5873f66][認可サービス側から見た場合、Semi-Hosted Serviceパターンにあたります。 https://qiita.com/TakahikoKawasaki/items/b2a4fc39e0c1a1949aab]

図: [UserPool → ...]




=={sec-ext} UserPoolのオススメの設定


=== 全てのエイリアス属性を設定する
皆さんが普段使っているWebサービス（例えばTwitter）では、ユーザー名だけでなくメールアドレスや電話番号でもログインができますね。
ユーザー管理にUserPoolを利用しても同じことができます。このとき、メールアドレスや電話番号は`エイリアスとしてマーキング`された状態になっています。

UserPoolでは、メールアドレス・電話番号・preferred_username（ユーザーが変更可能なユーザー名）をログインに利用可能する設定があり、エイリアスと呼ばれています。
この設定は、UserPoolの作成後に変更することができません。強い理由がない限り、全てのエイリアスを選択することをオススメします。

なお、メールアドレスや電話番号をユーザー名のエイリアスとして使うのではなく、ログイン時にユーザー名そのものとして利用することも可能です。その場合、アプリのインストール時に初めからアカウントが設定されているようなユーザー体験を作ることが難しくなります。
特別な要件がない限り、エイリアス属性として指定したほうが無難です。


=== クライアントアプリが直接UserPoolにサインアップできるかどうかを明示的に指定する
ユーザー管理にUserPoolを利用した場合のサインアップのフローは、大きく分けて次のどちらかです。

 1. クライアントアプリが直接UserPoolにサインアップする。
 2. クライアントアプリはバックエンドアプリと通信する。バックエンドアプリは、クライアントから受け取ったメールアドレスや電話番号などを利用して代わりにサインアップする。

本書では、それぞれ「クライアントアプリによる自己サインアップ」「管理者によるのユーザーアカウントの作成」と呼び分けることにしましょう。

2つのサインアップ方法のいずれを用いるかは要件によって異なります。デフォルトではどちらも可能となっていますが、もし管理者としてのユーザーアカウントの作成しかしない場合は、クライアントアプリによる自己サインアップは許可しないほうがわかりやすいでしょう。
あくまで私見ですが、次に紹介するケースではクライアントアプリによる自己サインアップを許可しないほうがよいと考えます。

 *  メールアドレスでサインアップする際に、ケースインセンシティブ（メールアドレスの大文字・小文字を問わず重複を許可しない）ようにしたい
 *  UserPool以外のユーザー管理サービスを併用しており、そのサービスで既にユーザーがいないかをサインアップ時に確認したい


=== ユーザーアカウントの有効期限を明示的に指定する
ユーザーのサインアップ方法として管理者によるユーザーアカウントの作成を選んだ場合、そのアカウントには有効期限があります。
アカウントの有効期限とは、つまりアカウント作成時に設定された初期パスワードの有効期限です。初期パスワードは管理者が指定できたり、メールやSMSで送信されたりするので、セキュリティを担保するために有効期限がついていると考えられます。
この有効期限は、特に指定しない場合はデフォルトで7日間となっています。どのような値にするかは要件次第ですが、ユーザーから初期パスワードが無効になってログインできない問い合わせが来たときにすぐに原因が分かるよう、明示的に値を指定すべきだと考えます。


=== メールの送信元にAWS SESを設定する。
メールアドレスの検証や初期パスワードの送信などで、ユーザーにメールを送信することがあります。UserPoolではデフォルトのメールの設定がありますが、以下の理由から利用するのは開発環境などに限定したほうがよいでしょう。@<fn>{993B91D2}

 * メールの送信元ドメインが `no-reply@verificationemail.com` になってしまう。
 * 1日に送信できるUserPoolあたりのメールの数などに制限がかかっている。

//footnote[993B91D2][公式ドキュメントでも案内があります。@<href>{https://docs.aws.amazon.com/ja_jp/cognito/latest/developerguide/user-pool-email.html}]

=={sec-ext} 開発のオススメ

=== 要件にあった構築・運用方法を選ぶ
他のAWSのリソースと同じく、UserPoolもマネジメントコンソール、CLI、IaC(CloudFormationなど)の3通りの方法による作成が考えられると思います。
要件に応じた構築・運用方法を選ぶことが大事です。それぞれの方法に対して、私の意見は以下のとおりです。

==== マネジメントコンソール
メリット: まずは作ってみたいとき、CLIやCloudFormationの雛形を作りたいときに有効です。
デメリット: 手作業で運用することになるため、作業量が多くなると大変。UserPoolクライアントを何種類も作成するのは苦労するかもしれません。

==== CLI
メリット: UserPoolの全てのAPIに対応しています。
デメリット: update-user-pool の仕様として、値を指定しなかった属性は初期値が設定されてしまいます。したがって、結局は宣言的な書き方をすることになります。


==== IaC(CloudFormationなど)
メリット: UserPoolクライアントやFederated Identityの関係性をコードで表現できます。Lambdaトリガーを設定する際に、都度ARNを調べないことが可能です。
デメリット: 2019-08-03時点で、ユーザー移行LambdaトリガーがCloudFormationに対応していません。


=== ユーザーの存在確認にはGetUserを用いる
UserPoolでは、ユーザーの検索に利用できるAPIが2種類用意されています。

 *  GetUser: ユーザー属性を取得する
 *  ListUsers: 複数のユーザーの属性を取得する

単数か複数かだけが違うように見えますが、ListUsersではエイリアス属性をユーザー名の代わりとしてユーザーを検索することができません。
ユーザーの存在チェックをするケースでは、ユーザーがログインに用いた一意識別子（＝usernameもしくはエイリアス属性）を利用することが多いと考えられます。したがって、GetUserを使うようにしてください。


=== パスワードリセット時に古いパスワードを無効にすべきかを検討する
UserPoolでは、ユーザーのパスワードをリセットするためのAPIが2種類用意されています。

 *  ForgotPassword: ユーザーがパスワードをリセットする
 *  AdminResetUserPassword: 管理者がパスワードをリセットする

このうち、ForgotPasswordでは古いパスワードを無効にすることはできませんが、AdminResetUserPasswordでは無効にすることができます。これは、ForgotPasswordが認証なしで誰でもリクエスト可能なAPIだからであると考えられます。
もしパスワードリセット時に古いパスワードを無効にすることが必要であれば、クライアントのリクエストをバックエンドで受け取り、その後バックエンドで管理者としてパスワードをリセットするフローも検討できると思います。


=== データベースに格納するIDとしては、基本的にusernameではなくsubを用いる
UserPool内でユーザーを一意に特定するための属性として、usernameとsubがあります。それぞれ以下のような違いがあります。

 * username: ユーザー作成時に登録する変更できない任意の文字列
 * sub: UserPoolがサインアップ時に作成する永続的なUUID

usernameはUserPoolの中で一意であるものの、ユーザーの削除後は再利用できる値です。したがって、基本的にはsubを利用することになります。
ただし、UserPoolとFederated Identityを接続して利用する場合は、Federated IdentityのIdentity IDを利用したほうがよいでしょう。理由は、Facebookアカウントなどを使ってFedetared Identityと接続するケースがあるためです。


=== UserPoolのクライアントIDを使い回さない
UserPoolでサインインやパスワードリセットなどのAPI（非認証API = IAM UserやRoleなしで利用できるAPI）を利用するには、UserPoolクライアントのクライアントIDおよびクライアントシークレットが必要です。
ここで、クライアントIDやクライアントシークレットは一度作成すると更新することができません。万が一流出したときの対応の影響範囲を最小限に留めるためにも、クライアントIDは使い回さないようにしましょう。

