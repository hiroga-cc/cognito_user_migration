= 実践UserPool

//abstract{
UserPoolを利用したシステムと、開発・設定のポイントについてご紹介します。
//}

== UserPoolを利用したシステムのアーキテクチャ
コンシューマー向けのWebサービスのバックエンドを想定して、Cognitoを利用したシステムを2通り紹介します。  
なお、その他のユースケースとしては、SPAにログイン機能を実装するケースや、エンタープライズの認証基盤の認証基盤として使うケースがあります。
今回は解説しないので、AWSの公式ドキュメントを参照ください。@<fn>{a81b8f32}
//footnote[a81b8f32][AWS Black Belt Online Seminar 2017 AWSにおけるアプリ認証パターンのご紹介https://www.slideshare.net/AmazonWebServicesJapan/aws-black-belt-online-seminar-2017-aws-80642202]


=== UserPoolをユーザー認証・認可基盤として利用するケース
UserPoolをクライアントによるユーザー認証とサーバーによるユーザー認証の両方で用いるケース（@<img>{architecture_1}）です。

//image[architecture_1][UserPoolをユーザー認証・認可基盤として利用するケース][scale=1.0]

サインイン〜リソースサーバーへのリクエストの処理の流れは以下の通りです。

 - 1. エンドユーザーはユーザー名・パスワード（など）を用いてUserPoolにログインします。
 - 2. UserPoolはIDトークン・アクセストークン・リフレッシュトークンを返却し、クライアントはそれを受け取ります。
 - 3. クライアントは受け取ったクレデンシャルを用いてリソースサーバーにリクエストします。@<br>{}

認証・認可（@<img>{architecture_1}の1,2）については、以下の3通りの実装パターンが考えられます。

 - A. UserPoolがホストする組み込みのサインイン・サインアップページを利用する。
 - B. JavaScriptアプリ/ネイティブアプリで、AWS Amplify（またはAWS SDK）を利用してUserPoolのAPIを直接呼び出す。
 - C. サインアップ・サインインを提供するAPIを実装し、サーバーサイドでUserPoolのAPIを呼び出す。@<br>{}

クライアントとリソースサーバーの提供元が同じ場合、パターンB.を利用するのが最もシンプルでしょう。
一方で、クライアントとリソースサーバーの提供元が異なる場合は、リソースサーバーへのアクセスをOAuth2.0に則って管理したいはずです。パターンA.を利用すれば画面を自前で実装しなくて良くなります。@<br>{}

ただし、パターンA.で利用している組み込みのサインイン・サインアップページは、UserPoolのカスタム認証フロー（自前で構築したパスワードレス認証など）には対応していません。その場合は、サインイン・サインアップページも自前で実装することになります。@<br>{}

また、リソースサーバーへのアクセス（@<img>{architecture_1}の3）については以下の3通りのパターンが考えられます。

 - D. API Gatewayのオーソライザーを用いてリクエストを検証する。
 - E. ALBの認証アクションを用いてリクエストを検証する。
 - F. リクエストの検証処理を自前でサーバーに実装する。@<br>{}

クライアントとリソースサーバーの提供元が同じ場合は、どのパターンでも実装が可能です。リクエストにセットされたIDトークンをUserPoolに対して検証できれば問題ありません。  
クライアントとリソースサーバーの提供元が異なる場合は、IDトークンではなくアクセストークンを受け取るはずです。API Gatewayのカスタムオーソライザーなどで検証処理を実装しましょう。@<br>{}


=== UserPoolをユーザー認証基盤として利用し、認可に別サービスを用いるケース

UserPoolをユーザー認証基盤として用い、認可は別のサービスに任せるケース（@<img>{architecture_2}）です。認可を担うサービスとしては、例えばFederated Identity, Authleteなどがあります。@<fn>{f5873f66}
//footnote[f5873f66][認可サービス側から見た場合、Semi-Hosted Serviceパターンにあたります。 https://qiita.com/TakahikoKawasaki/items/b2a4fc39e0c1a1949aab]

//image[architecture_2][UserPoolをユーザー認証・認可基盤として利用するケース][scale=1.0]

本ケースは、UserPool単体の認可の機能では要件が満たせないケースです。そのため、認可とリソースサーバーへのリクエストに絞って解説します。@<br>{}

UserPoolによる認可で要件が満たせないケースとしてまず挙げられるのは、クライアントがAWSのリソース（S3, DynamoDBなど）に直接アクセスするケースです。  
ユーザーに対してAWSの一時的な認証情報（アクセスキー、シークレットキー）を発行するため、認可サーバーとしてFederated Identityを利用することになります。  
その場合、バックエンドのAPIへのリクエストはAPI Gateway経由で公開するのが良いでしょう。API Gatewayを経由することで、サーバーサイドのアプリケーションをAWSのリソースとして扱うことができます。具体的には、API Gatewayの認証方法としてIAM認証を選択してください。@<br>{}

それ以外にも、UserPool単体では満たせない認可の要件がある場合は、認可サーバーを別に構築する必要があります。  
UserPoolおよび認可サーバーを自前のサーバーでラップし、クライアント向けのAPIとして提供する構成が考えられます。@<br>{}

//note[コラム: アプリケーション内でリクエストの検証をしないと嬉しいこと]{
アプリケーション内でリクエストの検証をしないと、実装すべき機能が減る以外にも嬉しいことがあります。  
それは、ローカルで認証レスなデバッグができることです。@<br>{}

例えば、リクエストの検証をAPI Gatewayのカスタムオーソライザーで実行した場合、バックエンドのアプリケーションはヘッダーにセットされたユーザーのSubを信用すれば処理ができます。  
その結果、ローカルでデバッグのたびに認証する必要がなくなり、またテスト自動化のコードも書きやすくなるのでオススメです。
//}


== UserPoolを利用したシステムの開発

=== 設定のポイント
UserPoolには多くの設定があります。
マネジメントコンソールではデフォルトの設定が用意されてはいますが、本番で運用する前に@<b>{絶対に理解しておくべき}設定もあります。いくつか見ていきましょう。@<br>{}

なお、カッコ内の英字はCloudFormationで定義する場合のプロパティ名です。

==== エイリアス属性(AliasAttributes)

ユーザーがユーザー名以外にも、メールアドレスや電話番号でログインができるようにするための設定です。  
この設定はデフォルトでメールアドレスのみが選択されており、しかも@<b>{後から変更できません}。必ず要件にあった設定になっているか確認してください。@<fn>{6552ebf2}@<br>{}

//footnote[6552ebf2][もしも誤って設定し、かつ後から変更したい場合には、2019-09-16 現在ではUserPoolからUserPoolにユーザー移行をする必要があります。]

もう少し詳しく説明すると、UserPoolでは、メールアドレス・電話番号・preferred_username（ユーザーが変更可能なユーザー名）をログインに利用可能する設定（@<img>{aliases}）があります。  
それらの属性でログイン可能にすることを、「エイリアス属性に指定する」と呼びます。@<br>{}

//image[aliases][全てのエイリアス属性が選択された状態][scale=1.0]

なお、メールアドレスや電話番号をユーザー名のエイリアスとして使うのではなく、ログイン時にユーザー名そのものとして利用することも可能です。その場合、アプリのインストール時に初めからアカウントが設定されているようなユーザー体験を作ることが難しくなります。
特別な要件がない限り、エイリアス属性として指定したほうが無難です。


==== ユーザーアカウントの有効期限(TemporaryPasswordValidityDays)

簡単に言うと、アカウント作成時に設定された初期パスワードの有効期限です。@<fn>{32a91a58}@<br>{}

UserPoolでは、管理者がユーザーアカウントの作成（サインアップ）をすることが可能です。  
その際、管理者は初期パスワードを自由に指定することができます。また、初期パスワードはSMSやメール経由でエンドユーザーに送信されます。
そのような仕様を踏まえ、初期パスワードの流出による被害を防ぐためか、管理者が作成したユーザー（の初期パスワード）には有効期限があり、デフォルトで7日間となっています。@<br>{}

有効期限を過ぎた場合、ユーザーが初回のサインインをすることができません。  
ユーザーからログインできない問い合わせが来たときにすぐに原因が分かるよう、どのような値が設定されているかを把握しておきましょう。@<br>{}

//footnote[32a91a58][ちなみに、2018年頃（詳細不明）までは UnusedAccountValidityDays というプロパティ名でした。やっぱり分かりづらかったのでしょう。]


==== メールの送信元(EmailConfiguration)

メールアドレスの検証や初期パスワードの送信などで、ユーザーにメールを送信することがあります。
UserPoolではデフォルトのメールの設定がありますが、以下の理由から利用するのは開発環境などに限定したほうがよいでしょう。@<fn>{993B91D2}@<br>{}

 * メールの送信元ドメインが `no-reply@verificationemail.com` になってしまい、ユーザーが混乱する。
 * 1日に送信できるUserPoolあたりのメールの数などに制限がかかっている。@<br>{}

//footnote[993B91D2][公式ドキュメントでも案内があります。@<href>{https://docs.aws.amazon.com/ja_jp/cognito/latest/developerguide/user-pool-email.html}]


==== 管理者のみがユーザーを作成可能(AllowAdminCreateUserOnly)

クライアントがUserPoolに直接サインアップできなくなる設定です。サインアップの前に特定のビジネスロジックを動かしたい場合などで有効だと考えられます。@<br>{}

あくまで私見ですが、次に紹介するケースではクライアントアプリによる自己サインアップを許可しないほうがよいと考えます。

 *  メールアドレスでサインアップする際に、ケースインセンシティブ（メールアドレスの大文字・小文字を問わず重複を許可しない）ようにしたい
 *  UserPool以外のユーザー管理サービスを併用しており、そのサービスで既にユーザーがいないかをサインアップ時に確認したい


=== API利用のポイント

==== InitiateAuth と ChangePassword のロック

InitiateAuth は、同じユーザーに対して連続で認証を失敗することが続くと、 NotAuthorizedException が発生し、メッセージとして Password attempts exceeded が返るようになります。
また、 ChangePassword を同じユーザーに対して一定の頻度で実行すると LimitExceededException エラーが返るようになります。これらのロック機能は、設定しなくても常に機能するようになっています。@<br>{}

ロックされる具体的な条件や期間、ロックが解除されるまでの期間は公開されていません。また、少なくとも InitiateAuth については、失敗した回数に応じて指数関数的に機能が増加する仕組みになっているようです。  


==== AdminGetUser と ListUsers の違い

UserPoolでは、バックエンドでユーザーの検索に利用できるAPIが2種類用意されています。

 *  AdminGetUser: ユーザー属性を取得する
 *  ListUsers: 複数のユーザーの属性を取得する@<br>{}

単数か複数かだけが違うように見えますが、ListUsersではエイリアス属性をユーザー名の代わりとしてユーザーを検索できない点が異なります。@<br>{}

ユーザーがログインに用いた一意識別子（＝usernameもしくはエイリアス属性）を利用してユーザーの存在チェックをするケースでは、AdminGetUserを使ったほうが実装がシンプルになります。
以下に具体的なコードを挙げます。@<br>{}

//emlist[ユーザーの存在チェック]{
// TypeScript

const adminGetUser = async (uniqueIdentifier: string) => {
    return new Promise((resolve, reject) => {
        cognitoProvider.adminGetUser({
            UserPoolId: USER_POOL_ID,
            Username: uniqueIdentifier // Usernameというキー名だが、エイリアス属性であればメールアドレスや電話番号でも問題ない。
        }, (err: any, data: any) => {
            if (err) {
                console.error(`UserNotFound`)
                reject(err)
            } else {
                resolve(data)
            }
        })
    })
}
//}

==== ForgotPassword と AdminResetUserPassword の違い

UserPoolでは、ユーザーのパスワードをリセットするためのAPIが2種類用意されています。

 * ForgotPassword: ユーザーがパスワードをリセットする
 * AdminResetUserPassword: 管理者がパスワードをリセットする@<br>{}

このうち、 ForgotPassword では古いパスワードを無効にすることはできませんが、 AdminResetUserPassword では無効にすることができます。
これは、 ForgotPassword が認証なしで誰でもリクエスト可能なAPIだからであると考えられます。  
もしパスワードリセット時に古いパスワードを無効にすることが必要であれば、クライアントのリクエストをバックエンドで受け取り、その後バックエンドで管理者としてパスワードをリセットするフローを検討しましょう。



=== 構築・運用のポイント

他のAWSのリソースと同じく、UserPoolもマネジメントコンソール、CLI、ソースコード(CloudFormation, CDK)の3通りの方法による作成が考えられると思います。
要件に応じた構築・運用方法を選ぶことが大事です。それぞれの方法に対して、私の意見は以下のとおりです。@<br>{}

==== マネジメントコンソール
 - Pros. まずは作ってみたいとき、CLIやCloudFormationの雛形を作りたいときに有効です。
 - Cons. 複数の環境にUserPool・UserPoolクライアントを作成する場合は大変かもしれません。

==== CLI
 - Pros. inputをjsonで管理でき、かつ対応していないパラメータが（少なくとも筆者が体験したことは）ありません。
 - Cons. consというか気をつける点ですが、update-user-pool の仕様として、値を指定しなかった属性は初期値が設定されてしまいます。したがって、結局は宣言的な書き方をすることになります。

==== ソースコード(CloudFormation, CDK)
 - Pros. UserPoolクライアントやFederated Identityの関係性をコードで表現できます。Lambdaトリガーを設定する際に、都度ARNを調べずに済みます。
 - Cons. 2019-08-03時点で、ユーザー移行LambdaトリガーがCloudFormationに対応していません。


//note[コラム: usernameとsubの違い]{
UserPool内でユーザーを一意に特定するための属性として、usernameとsubがあります。
それぞれ以下のような違いがあります。  

 * username: ユーザー作成時に登録する変更できない任意の文字列
 * sub: UserPoolがサインアップ時に作成する永続的なUUID

usernameはUserPoolの中で一意であるものの、ユーザーの削除後は再利用できる値です。
したがって、アプリケーション内でユーザーを一意にする値としては、基本的にsubを利用することになります。  
ただし、UserPoolとFederated Identityを接続して利用する場合は、Federated IdentityのIdentity IDを利用したほうがよいでしょう。
理由は、Facebookアカウントなどを使ってFedetared Identityと接続するケースがあるためです。
//}
